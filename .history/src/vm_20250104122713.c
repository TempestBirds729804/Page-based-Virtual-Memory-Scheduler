#ifdef _WIN32
#include <windows.h>
#endif
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include "../include/vm.h"
#include "../include/memory.h"

// ???????????????????
uint32_t select_victim_page(PCB* process);
bool swap_out_page(uint32_t frame);
void clock_tick_handler(void);
uint64_t get_current_time(void);

// ?????????????????????????????????????????
VMManager vm_manager;

// ????????????
PageReplacementStats page_stats = {0};

/**
 * @brief ??????????????????????Ÿ¨?????????????????
 */
void vm_init(void) {
    // ???Ÿ¨??????????ÔÖ??????????????SwapBlockInfo
    vm_manager.swap_blocks = (SwapBlockInfo*)calloc(SWAP_SIZE, sizeof(SwapBlockInfo));
    // ???Ÿ¨???????????????
    vm_manager.swap_area = malloc(SWAP_SIZE * SWAP_BLOCK_SIZE);
    // ????????ßﬂ?????????
    vm_manager.swap_free_blocks = SWAP_SIZE;
    
    // ?????????????????
    memset(&vm_manager.stats, 0, sizeof(MemoryStats));

    // ??????????????
    if (!vm_manager.swap_blocks || !vm_manager.swap_area) {
        fprintf(stderr, "??????????\n");
        exit(1); // ?????????????????
    }
}

/**
 * @brief ??????ó®??????ß’??????????????ßÿ?
 * 
 * @param process ??????????PCB
 * @param virtual_address ????????????
 * @param is_write ????ß’????
 */
void access_memory(PCB* process, uint32_t virtual_address, bool is_write) {
    if (!process || !process->page_table) {
        printf("??????ßπ?????????\n");
        return;
    }
    
    vm_manager.stats.total_accesses++;
    
    // ??????????????
    uint32_t page_num = (virtual_address & 0xFFFFF000) >> 12;  // ??20¶À????
    uint32_t offset = virtual_address & 0xFFF;                 // ??12¶À???????
    
    if (page_num >= process->page_table_size) {
        printf("????????? 0x%x (???=%u, ???=0x%x) ?????????????¶∂\n", 
               virtual_address, page_num, offset);
        return;
    }
    
    PageTableEntry* pte = &process->page_table[page_num];
    
    // ????????????????
    if (!pte->flags.present) {
        printf("\n=== ??????????ßÿ? ===\n");
        vm_manager.stats.page_faults++;
        if (!handle_page_fault(process, page_num)) {
            printf("????????????? 0x%x\n", virtual_address);
            return;
        }
    }
    
    // ?????????????
    uint64_t current_time = get_current_time();
    pte->last_access_time = current_time;
    
    // ????????????????
    if (pte->flags.present) {
        uint32_t frame = pte->frame_number;
        memory_manager.frames[frame].last_access_time = current_time;
        
        if (is_write) {
            pte->flags.dirty = true;
            memory_manager.frames[frame].is_dirty = true;
            printf("???? %d ß’???? 0x%x (???=%u, ???=0x%x, ???=%u)\n", 
                   process->pid, virtual_address, page_num, offset, frame);
        } else {
            printf("???? %d ?????? 0x%x (???=%u, ???=0x%x, ???=%u)\n", 
                   process->pid, virtual_address, page_num, offset, frame);
        }
    }
}

/**
 * @brief ???????ßÿ????????????????
 * 
 * @param process ??????????PCB
 * @param virtual_address ??????????????
 * @return true ???????
 * @return false ???????
 */
bool handle_page_fault(PCB* process, uint32_t virtual_page) {
    printf("\n=== ??????????ßÿ? ===\n");
    printf("???? %u ??????? %u\n", process->pid, virtual_page);
    
    // ??????????
    vm_manager.stats.page_faults++;
    process->stats.page_faults++;
    
    // ???????????ßπ
    if (virtual_page >= process->page_table_size) {
        printf("??????? %u ?????????¶∂ %u\n", virtual_page, process->page_table_size);
        return false;
    }
    
    PageTableEntry* pte = &process->page_table[virtual_page];
    printf("???????present=%d, swapped=%d\n", 
           pte->flags.present, pte->flags.swapped);
    
    // ??????????????
    uint32_t frame = allocate_frame(process->pid, virtual_page);
    
    // ?????ß·???????????????????
    if (frame == (uint32_t)-1) {
        printf("\n=== ?????????????????? ===\n");
        printf("????????????: %u\n", memory_manager.free_frames_count);
        
        // ??????????
        vm_manager.stats.page_replacements++;
        process->stats.page_replacements++;
        
        // ???????????????
        uint32_t victim_frame = select_victim_frame();
        if (victim_frame == (uint32_t)-1) {
            printf("?????????????ùI?????\n");
            return false;
        }
        
        // ???????????????
        PCB* victim_process = get_process_by_pid(memory_manager.frames[victim_frame].process_id);
        if (!victim_process) {
            printf("??????????????????????????\n");
            return false;
        }
        
        uint32_t victim_page = memory_manager.frames[victim_frame].virtual_page_num;
        printf("?????? %u ????? %u (??? %u) ???????\n", 
               victim_process->pid, victim_page, victim_frame);
        
        // ?????õR?????????ß’??????
        if (memory_manager.frames[victim_frame].is_dirty) {
            vm_manager.stats.disk_writes++;
            if (!swap_out_page(victim_frame)) {
                printf("??????ùI?????\n");
                return false;
            }
            vm_manager.stats.pages_swapped_out++;
            victim_process->stats.pages_swapped_out++;
        }
        
        // ???°¿?????????????
        PageTableEntry* victim_pte = &victim_process->page_table[victim_page];
        victim_pte->flags.present = false;
        victim_pte->flags.swapped = true;
        victim_pte->frame_number = (uint32_t)-1;
        
        // ?????????????????
        frame = victim_frame;
        memory_manager.frames[frame].is_allocated = true;
        memory_manager.frames[frame].process_id = process->pid;
        memory_manager.frames[frame].virtual_page_num = virtual_page;
        memory_manager.frames[frame].last_access_time = get_current_time();
        memory_manager.frames[frame].is_dirty = false;
    }
    
    // ??????????????????????
    if (pte->flags.swapped) {
        vm_manager.stats.disk_reads++;
        process->stats.pages_swapped_in++;
        if (!swap_in_page(process->pid, virtual_page, frame)) {
            printf("?????????????\n");
            return false;
        }
    }
    
    // ?????????
    pte->frame_number = frame;
    pte->flags.present = true;
    pte->flags.swapped = false;
    pte->last_access_time = get_current_time();
    
    printf("??? %u ????????? %u\n", virtual_page, frame);
    
    return true;
}

/**
 * @brief ?????????????????
 * 
 * @param process ??????????PCB
 */
void dump_page_table(PCB* process) {
    printf("\n=== ????? (PID=%u) ===\n", process->pid);
    int present_count = 0, swapped_count = 0;
    
    // ??????????ó®?????
    for (uint32_t i = 0; i < process->page_table_size; i++) {
        PageTableEntry* pte = &process->page_table[i];
        if (pte->flags.present || pte->flags.swapped) { // ??????????ß›???????????
            printf("???: %u, ??: %s%s, ???: %u\n",
                   i,
                   pte->flags.present ? "?????" : "¶ƒ????",
                   pte->flags.swapped ? ", ?????" : "",
                   pte->flags.present ? pte->frame_number : pte->flags.swap_index);
            
            // ?????????????
            if (pte->flags.present) present_count++;
            if (pte->flags.swapped) swapped_count++;
        }
    }
    
    // ?????????
    printf("\n???????: %d, ??????????: %d\n",
           present_count, swapped_count);
}

/**
 * @brief ???????????????????????ßŸ???????
 */
void vm_shutdown(void) {
    free(vm_manager.swap_blocks); // ???????????????
    free(vm_manager.swap_area);   // ???????????????
}

/**
 * @brief ????????????ÔÖ??????ù©??
 * 
 * @param process_id ????ID
 * @param virtual_page ???????
 * @return uint32_t ?????????????????????? -1
 */
uint32_t allocate_swap_block(uint32_t process_id, uint32_t virtual_page) {
    if (vm_manager.swap_free_blocks == 0) { // ???????ß·??ßﬂ?????
        return (uint32_t)-1;
    }

    // ?????????ÔÖ????????¶ƒ?????????
    for (uint32_t i = 0; i < SWAP_SIZE; i++) {
        if (!vm_manager.swap_blocks[i].is_used) {
            vm_manager.swap_blocks[i].is_used = true; // ?????????
            vm_manager.swap_blocks[i].process_id = process_id; // ???????ID
            vm_manager.swap_blocks[i].virtual_page = virtual_page; // ??????????
            vm_manager.swap_free_blocks--; // ??????ßﬂ????????
            return i; // ?????????????
        }
    }
    return (uint32_t)-1; // ¶ƒ??????ßﬂ?????
}

/**
 * @brief ????????????
 * 
 * @param swap_index ??????????????
 */
void free_swap_block(uint32_t swap_index) {
    // ??˝Ç??????????ßπ????????
    if (swap_index < SWAP_SIZE && vm_manager.swap_blocks[swap_index].is_used) {
        vm_manager.swap_blocks[swap_index].is_used = false; // ????¶ƒ???
        vm_manager.swap_blocks[swap_index].process_id = 0; // ???????ID
        vm_manager.swap_blocks[swap_index].virtual_page = 0; // ??????????
        vm_manager.swap_free_blocks++; // ??????ßﬂ????????
    }
}

/**
 * @brief ????ù©????????????
 * 
 * @param process ??????????PCB
 * @param page_num ?????????????
 * @return true ???????
 * @return false ???????
 */
bool page_out(PCB* process, uint32_t page_num) {
    // ??????????????????
    if (!process || page_num >= process->page_table_size ||
        !process->page_table[page_num].flags.present) {
        printf("??????? %u ?????????\n", page_num);
        return false;
    }

    PageTableEntry* pte = &process->page_table[page_num];
    // ????????????????
    if (!pte->flags.present) {
        printf("??????? %u ?????????\n", page_num);
        return false;
    }

    // ???Ÿ¨????
    uint32_t swap_index = allocate_swap_block(process->pid, page_num);
    if (swap_index == (uint32_t)-1) { // ???????????
        printf("??????????Ÿ¨???˜œ??????Ôì%u??\n", 
               vm_manager.swap_free_blocks);
        return false;
    }

    // ????????????????????
    uint8_t page_data[PAGE_SIZE];
    if (!read_physical_memory(pte->frame_number, 0, page_data, PAGE_SIZE)) {
        printf("???????????????????????????????%u??\n", 
               pte->frame_number);
        free_swap_block(swap_index); // ???????????????
        return false;
    }
    
    // ?????????ß’??????
    if (!write_to_swap(swap_index, page_data)) {
        printf("???????ß’????????????????%u??\n", swap_index);
        free_swap_block(swap_index); // ß’??????????????
        return false;
    }

    // ???????????????????
    free_frame(pte->frame_number); // ????????
    pte->frame_number = (uint32_t)-1; // ???????
    pte->flags.present = false; // ?????÷Œ???????
    pte->flags.swapped = true; // ???????????
    pte->flags.swap_index = swap_index; // ?????????????
    
    // ?????????????
    vm_manager.stats.page_replacements++;
    printf("??? %u ????????????? %u\n", page_num, swap_index);
    return true;
}

/**
 * @brief ???????????
 * 
 * @param process ??????????PCB
 * @param virtual_page ?????????????
 * @return true ??????
 * @return false ???????
 */
bool page_in(PCB* process, uint32_t virtual_page) {
    // ?????????????ßπ??
    if (!process || virtual_page >= process->page_table_size) {
        return false;
    }

    PageTableEntry* pte = &process->page_table[virtual_page];
    // ??????????????
    if (!pte->flags.swapped) {
        return false; // ???¶ƒ???????????????
    }

    // ????????????
    uint32_t frame = allocate_frame(process->pid, virtual_page);
    if (frame == (uint32_t)-1) { // ??÷Œ??
        uint32_t victim_page = select_victim_page(process); // ?????????
        if (victim_page != (uint32_t)-1) {
            printf("?????? %u ???ßﬂ???\n", victim_page);
            if (page_out(process, victim_page)) { // ???????ù©????
                frame = allocate_frame(process->pid, virtual_page); // ??¶√???????
            }
        }
    }

    if (frame == (uint32_t)-1) { // ??????????????
        return false;
    }

    // ????????????????
    uint8_t page_data[PAGE_SIZE];
    uint32_t swap_index = pte->flags.swap_index;
    if (!read_from_swap(swap_index, page_data)) {
        free_frame(frame); // ???????????
        return false;
    }

    // ?????????ß’?????????
    if (!write_physical_memory(frame, 0, page_data, PAGE_SIZE)) {
        free_frame(frame); // ß’??????????
        return false;
    }

    // ??????????????????????
    pte->frame_number = frame;
    pte->flags.present = true; // ?????????????
    pte->flags.swapped = false; // ???????¶À
    
    printf("??? %u ???????ó®?????? %u\n", 
           virtual_page, swap_index);
    return true;
}

/**
 * @brief ?????????ß÷??????????
 * 
 * @return uint32_t ???ßﬂ?????????
 */
uint32_t get_free_swap_blocks(void) {
    return vm_manager.swap_free_blocks;
}

/**
 * @brief ?????????????????
 */
void print_vm_stats(void) {
    float page_fault_rate = vm_manager.stats.total_accesses > 0 ? 
        (float)vm_manager.stats.page_faults * 100 / vm_manager.stats.total_accesses : 0;
    
    printf("=== ????????? ===\n");
    printf("????????: %u\n", vm_manager.stats.total_accesses);
    printf("??????: %u (%.1f%%)\n", vm_manager.stats.page_faults, page_fault_rate);
    printf("????ùI????: %u\n", vm_manager.stats.page_replacements);
    printf("ß’????????: %u\n", vm_manager.stats.disk_writes);
    printf("??ùI??????: %u\n", vm_manager.stats.pages_swapped_out);
    printf("??ùI?????: %u\n", vm_manager.stats.pages_swapped_in);
    
    printf("\n=== ???????? ===\n");
    printf("?????????: %u\n", SWAP_SIZE);
    printf("?????????: %u\n", SWAP_SIZE - vm_manager.swap_free_blocks);
    printf("???ßﬂ?????: %u\n", vm_manager.swap_free_blocks);
    
    float fragmentation = 0;
    if (memory_manager.free_frames_count > 0) {
        uint32_t fragments = count_memory_fragments();
        fragmentation = (float)fragments * 100 / memory_manager.free_frames_count;
    }
    
    printf("\n=== ????????? ===\n");
    printf("?????????: %u\n", memory_manager.free_frames_count);
    printf("?????: %u\n", count_memory_fragments());
    printf("?????: %.1f%%\n", fragmentation);
}

/**
 * @brief ??????????????????
 * 
 * @param process ??????????PCB
 * @return uint32_t ???????????¶ƒ?????? -1
 */
uint32_t select_victim_page(PCB* process) {
    uint32_t victim_page = (uint32_t)-1;
    uint64_t oldest_access = UINT64_MAX;
    
    for (uint32_t i = 0; i < process->page_table_size; i++) {
        if (process->page_table[i].flags.present) {
            if (process->page_table[i].last_access_time < oldest_access) {
                oldest_access = process->page_table[i].last_access_time;
                victim_page = i;
            }
        }
    }
    return victim_page;
}

/**
 * @brief ?????????ß’???????????
 * 
 * @param process ??????????PCB
 * @param virtual_address ?ß’?????????
 * @param data ?ß’??????????
 * @param size ?ß’????????ß≥
 * @return true ß’????
 * @return false ß’?????
 */
bool write_page_data(PCB* process, uint32_t virtual_address, const void* data, size_t size) {
    uint32_t page_num = virtual_address / PAGE_SIZE;
    if (!process || page_num >= process->page_table_size) {
        return false;
    }

    // ?????????????
    if (!process->page_table[page_num].flags.present) {
        if (!handle_page_fault(process, virtual_address)) {
            return false;
        }
    }

    // ????????????ß’??????
    uint32_t frame = process->page_table[page_num].frame_number;
    if (!write_physical_memory(frame, 0, data, size)) {
        return false;
    }

    // ?????????
    process->page_table[page_num].last_access_time = get_current_time();
    return true;
}

/**
 * @brief ?????????????????????
 * 
 * @param process ??????????PCB
 * @param virtual_address ????????????
 * @param buffer ?õ•?????????????
 * @param size ???????????ß≥
 * @return true ??????
 * @return false ??????
 */
bool read_page_data(PCB* process, uint32_t virtual_address, void* buffer, size_t size) {
    uint32_t page_num = virtual_address / PAGE_SIZE;
    if (!process || page_num >= process->page_table_size) {
        return false;
    }

    // ?????????????
    if (!process->page_table[page_num].flags.present) {
        if (!handle_page_fault(process, virtual_address)) {
            return false;
        }
    }

    // ???????????????????
    uint32_t frame = process->page_table[page_num].frame_number;
    if (!read_physical_memory(frame, 0, buffer, size)) {
        return false;
    }

    // ?????????
    process->page_table[page_num].last_access_time = get_current_time();
    return true;
}

/**
 * @brief ??????ß’?????????????????
 * 
 * @param swap_index ??????????
 * @param data ?ß’??????????
 * @return true ß’????
 * @return false ß’?????
 */
bool write_to_swap(uint32_t swap_index, const void* data) {
    if (swap_index >= SWAP_SIZE || !data) { // ??˝Ç????????????????ßπ??
        return false;
    }

    // ??˝Ç?????????????
    if (!vm_manager.swap_blocks[swap_index].is_used) {
        return false;
    }

    // ?????????ßﬂ????????????
    uint8_t* dest = (uint8_t*)vm_manager.swap_area + (swap_index * SWAP_BLOCK_SIZE);
    memcpy(dest, data, SWAP_BLOCK_SIZE); // ????????????????
    vm_manager.stats.writes_to_disk++; // ????ß’????????

    return true; // ß’????
}

/**
 * @brief ?????????????????????
 * 
 * @param swap_index ??????????
 * @param buffer ?õ•?????????????
 * @return true ??????
 * @return false ??????
 */
bool read_from_swap(uint32_t swap_index, void* buffer) {
    if (swap_index >= SWAP_SIZE || !buffer) { // ??˝Ç?????????????????ßπ??
        return false;
    }

    // ??˝Ç?????????????
    if (!vm_manager.swap_blocks[swap_index].is_used) {
        return false;
    }

    // ?????????ßﬂ????????????
    uint8_t* src = (uint8_t*)vm_manager.swap_area + (swap_index * SWAP_BLOCK_SIZE);
    memcpy(buffer, src, SWAP_BLOCK_SIZE); // ????????????????

    return true; // ??????
}

/**
 * @brief ????????????????
 * 
 * @return SwapBlockInfo* ?????????????????
 */
SwapBlockInfo* get_swap_blocks(void) {
    return vm_manager.swap_blocks;
}

/**
 * @brief ?????????????????????
 * 
 * @return void* ?????????????????
 */
void* get_swap_area(void) {
    return vm_manager.swap_area;
}

/**
 * @brief ?????????????????
 * 
 * @return MemoryStats ?????????????
 */
MemoryStats get_memory_stats(void) {
    return vm_manager.stats;
}

/**
 * @brief ???????????????????????ß÷??????
 */
void clean_swap_area(void) {
    for (uint32_t i = 0; i < SWAP_BLOCKS; i++) {
        if (vm_manager.swap_blocks[i].is_used) { // ??˝Ç??????????
            vm_manager.swap_blocks[i].is_used = false; // ????¶ƒ???
            vm_manager.swap_blocks[i].process_id = 0; // ???????ID
            vm_manager.swap_blocks[i].virtual_page = 0; // ??????????
            vm_manager.swap_free_blocks++; // ??????ßﬂ????????
        }
    }
}

/**
 * @brief ????????????????????????????????????ß‹???????????
 */
void print_swap_status(void) {
    uint32_t used_blocks = 0;
    // ??????????????????
    for (uint32_t i = 0; i < SWAP_BLOCKS; i++) {
        if (vm_manager.swap_blocks[i].is_used) {
            used_blocks++;
        }
    }
    printf("???????: %u\n", SWAP_BLOCKS);
    printf("???ßﬂ?????: %u\n", SWAP_BLOCKS - used_blocks);
    printf("??????????: %u\n", used_blocks);
    
    printf("\n????????\n");
    // ?????????????????????
    for (uint32_t i = 0; i < SWAP_BLOCKS; i++) {
        if (vm_manager.swap_blocks[i].is_used) {
            printf(" %u: PID=%u, ???=%u\n",
                   i,
                   vm_manager.swap_blocks[i].process_id,
                   vm_manager.swap_blocks[i].virtual_page);
        }
    }
}

/**
 * @brief ???????ùI??????
 * 
 * @return uint32_t ????ùI??????
 */
uint32_t get_last_replaced_page(void) {
    return vm_manager.stats.last_replaced_page;
}

/**
 * @brief ????????ùI????????
 * 
 * @param page_num ???ùI??????
 */
void update_replacement_stats(uint32_t page_num) {
    vm_manager.stats.page_replacements++; // ????????ùI????
    vm_manager.stats.last_replaced_page = page_num; // ???????ùI??????
    printf("????ùI????? %u ???ùI???ùI???? %u\n", 
           page_num, vm_manager.stats.page_replacements);
}

/**
 * @brief ?????ß’??????
 * 
 * @param frame ?ß’???????
 * @return true ß’????
 * @return false ß’?????
 */
bool swap_out_page(uint32_t frame) {
    if (frame >= PHYSICAL_PAGES || !memory_manager.frames[frame].is_allocated) {
        printf("??????ßπ?????? %u\n", frame);
        return false;
    }

    FrameInfo* frame_info = &memory_manager.frames[frame];
    PCB* process = get_process_by_pid(frame_info->process_id);
    if (!process) {
        printf("????????????? %u\n", frame_info->process_id);
        return false;
    }

    uint32_t virtual_page = frame_info->virtual_page_num;
    if (virtual_page >= process->page_table_size) {
        printf("??????????? %u ??????¶∂\n", virtual_page);
        return false;
    }

    // ???Ÿ¨????
    uint32_t swap_index = allocate_swap_block(process->pid, virtual_page);
    if (swap_index == (uint32_t)-1) {
        printf("??????????Ÿ¨????\n");
        return false;
    }

    // ?????????ß’??????
    void* page_data = get_physical_memory() + (frame * PAGE_SIZE);
    if (!write_to_swap(swap_index, page_data)) {
        printf("????ß’?????????\n");
        free_swap_block(swap_index);
        return false;
    }

    // ?????????
    PageTableEntry* pte = &process->page_table[virtual_page];
    pte->flags.present = false;
    pte->flags.swapped = true;
    pte->flags.swap_index = swap_index;

    // ??????????
    if (frame_info->is_dirty) {
        vm_manager.stats.disk_writes++;
    }
    vm_manager.stats.pages_swapped_out++;

    // ?????????
    frame_info->is_allocated = false;
    frame_info->process_id = 0;
    frame_info->virtual_page_num = 0;
    frame_info->is_dirty = false;
    memory_manager.free_frames_count++;

    printf("?????ß’????????????=%u, ???????=%u, ??????=%u\n", 
           process->pid, virtual_page, swap_index);

    return true;
}

/**
 * @brief ?????????
 * 
 * @return uint64_t ??????
 */
uint64_t get_current_time(void) {
#ifdef _WIN32
    // Windows?????GetSystemTimeAsFileTime
    FILETIME ft;
    GetSystemTimeAsFileTime(&ft);
    ULARGE_INTEGER uli;
    uli.LowPart = ft.dwLowDateTime;
    uli.HighPart = ft.dwHighDateTime;
    // ??????? (Windows?????????1601?????100??????)
    return (uli.QuadPart - 116444736000000000ULL) / 10;
#else
    // ??Windows?????clock_gettime
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (ts.tv_sec * 1000000) + (ts.tv_nsec / 1000);
#endif
}

/**
 * @brief ???????????????
 */
void print_page_replacement_stats(void) {
    printf("\n=== ???????????? ===\n");
    printf("????????: %u\n", page_stats.total_page_faults);
    printf("??????????: %u\n", page_stats.page_replacements);
    printf("??????????: %u\n", page_stats.disk_reads);
    printf("????ß’?????: %u\n", page_stats.disk_writes);
    printf("LRU??????: %.2f%%\n", 
           page_stats.lru_hits + page_stats.lru_misses > 0 ?
           (float)page_stats.lru_hits / (page_stats.lru_hits + page_stats.lru_misses) * 100 : 0);
}

/**
 * @brief ¥”Ωªªª«¯Ω´“≥√Êº”‘ÿµΩƒ⁄¥Ê
 * 
 * @param pid Ω¯≥ÃID
 * @param virtual_page –Èƒ‚“≥∫≈
 * @param frame ƒø±Í“≥øÚ∫≈
 * @return true º”‘ÿ≥…π¶
 * @return false º”‘ÿ ß∞‹
 */
bool swap_in_page(uint32_t pid, uint32_t virtual_page, uint32_t frame) {
    // ºÏ≤È≤Œ ˝”––ß–‘
    if (frame >= PHYSICAL_PAGES) {
        printf("¥ÌŒÛ£∫Œﬁ–ßµƒ“≥øÚ∫≈ %u\n", frame);
        return false;
    }

    // ≤È’“∂‘”¶µƒΩªªª«¯øÈ
    uint32_t swap_index = (uint32_t)-1;
    for (uint32_t i = 0; i < SWAP_SIZE; i++) {
        if (vm_manager.swap_blocks[i].is_used &&
            vm_manager.swap_blocks[i].process_id == pid &&
            vm_manager.swap_blocks[i].virtual_page == virtual_page) {
            swap_index = i;
            break;
        }
    }

    if (swap_index == (uint32_t)-1) {
        printf("¥ÌŒÛ£∫‘⁄Ωªªª«¯÷–’“≤ªµΩΩ¯≥Ã %u µƒ“≥√Ê %u\n", pid, virtual_page);
        return false;
    }

    // ∂¡»°Ωªªª«¯ ˝æ›
    uint8_t page_data[PAGE_SIZE];
    if (!read_from_swap(swap_index, page_data)) {
        printf("¥ÌŒÛ£∫¥”Ωªªª«¯∂¡»° ˝æ› ß∞‹\n");
        return false;
    }

    // Ω´ ˝æ›–¥»ÎŒÔ¿Ìƒ⁄¥Ê
    if (!write_physical_memory(frame, 0, page_data, PAGE_SIZE)) {
        printf("¥ÌŒÛ£∫–¥»ÎŒÔ¿Ìƒ⁄¥Ê ß∞‹\n");
        return false;
    }

    //  Õ∑≈Ωªªª«¯øÈ
    free_swap_block(swap_index);

    // ∏¸–¬Õ≥º∆–≈œ¢
    vm_manager.stats.disk_reads++;
    vm_manager.stats.pages_swapped_in++;

    printf("“≥√Ê≥…π¶¥”Ωªªª«¯º”‘ÿµΩƒ⁄¥Ê£∫PID=%u, –Èƒ‚“≥∫≈=%u, “≥øÚ=%u\n", 
           pid, virtual_page, frame);
    return true;
}
