#ifdef _WIN32
#include <windows.h>
#endif
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include "../include/vm.h"
#include "../include/memory.h"

// ???????????????????
uint32_t select_victim_page(PCB* process);
bool swap_out_page(uint32_t frame);
void clock_tick_handler(void);
uint64_t get_current_time(void);

// ?????????????????????????????????????????
VMManager vm_manager;

// ????????????
PageReplacementStats page_stats = {0};

/**
 * @brief ??????????????????????佻?????????????????
 */
void vm_init(void) {
    // ???佻????????????????????????SwapBlockInfo
    vm_manager.swap_blocks = (SwapBlockInfo*)calloc(SWAP_SIZE, sizeof(SwapBlockInfo));
    // ???佻???????????????
    vm_manager.swap_area = malloc(SWAP_SIZE * SWAP_BLOCK_SIZE);
    // ????????н?????????
    vm_manager.swap_free_blocks = SWAP_SIZE;
    
    // ?????????????????
    memset(&vm_manager.stats, 0, sizeof(MemoryStats));

    // ??????????????
    if (!vm_manager.swap_blocks || !vm_manager.swap_area) {
        fprintf(stderr, "??????????\n");
        exit(1); // ?????????????????
    }
}

/**
 * @brief ????????????д??????????????ж?
 * 
 * @param process ??????????PCB
 * @param virtual_address ????????????
 * @param is_write ????д????
 */
void access_memory(PCB* process, uint32_t virtual_address, bool is_write) {
    if (!process || !process->page_table) {
        printf("??????Ч?????????\n");
        return;
    }
    
    vm_manager.stats.total_accesses++;
    
    // ??????????????
    uint32_t page_num = (virtual_address & 0xFFFFF000) >> 12;  // ??20λ????
    uint32_t offset = virtual_address & 0xFFF;                 // ??12λ???????
    
    if (page_num >= process->page_table_size) {
        printf("????????? 0x%x (???=%u, ???=0x%x) ?????????????Χ\n", 
               virtual_address, page_num, offset);
        return;
    }
    
    PageTableEntry* pte = &process->page_table[page_num];
    
    // ????????????????
    if (!pte->flags.present) {
        printf("\n=== ??????????ж? ===\n");
        vm_manager.stats.page_faults++;
        if (!handle_page_fault(process, page_num)) {
            printf("????????????? 0x%x\n", virtual_address);
            return;
        }
    }
    
    // ?????????????
    uint64_t current_time = get_current_time();
    pte->last_access_time = current_time;
    
    // ????????????????
    if (pte->flags.present) {
        uint32_t frame = pte->frame_number;
        memory_manager.frames[frame].last_access_time = current_time;
        
        if (is_write) {
            pte->flags.dirty = true;
            memory_manager.frames[frame].is_dirty = true;
            printf("???? %d д???? 0x%x (???=%u, ???=0x%x, ???=%u)\n", 
                   process->pid, virtual_address, page_num, offset, frame);
        } else {
            printf("???? %d ?????? 0x%x (???=%u, ???=0x%x, ???=%u)\n", 
                   process->pid, virtual_address, page_num, offset, frame);
        }
    }
}

/**
 * @brief ???????ж????????????????
 * 
 * @param process ??????????PCB
 * @param virtual_address ??????????????
 * @return true ???????
 * @return false ???????
 */
bool handle_page_fault(PCB* process, uint32_t virtual_page) {
    printf("\n=== ??????????ж? ===\n");
    printf("???? %u ??????? %u\n", process->pid, virtual_page);
    
    // ??????????
    vm_manager.stats.page_faults++;
    process->stats.page_faults++;
    
    // ???????????Ч
    if (virtual_page >= process->page_table_size) {
        printf("??????? %u ?????????Χ %u\n", virtual_page, process->page_table_size);
        return false;
    }
    
    PageTableEntry* pte = &process->page_table[virtual_page];
    printf("???????present=%d, swapped=%d\n", 
           pte->flags.present, pte->flags.swapped);
    
    // ??????????????
    uint32_t frame = allocate_frame(process->pid, virtual_page);
    
    // ?????п???????????????????
    if (frame == (uint32_t)-1) {
        printf("\n=== ?????????????????? ===\n");
        printf("????????????: %u\n", memory_manager.free_frames_count);
        
        // ??????????
        vm_manager.stats.page_replacements++;
        process->stats.page_replacements++;
        
        // ???????????????
        uint32_t victim_frame = select_victim_frame();
        if (victim_frame == (uint32_t)-1) {
            printf("?????????????I?????\n");
            return false;
        }
        
        // ???????????????
        PCB* victim_process = get_process_by_pid(memory_manager.frames[victim_frame].process_id);
        if (!victim_process) {
            printf("??????????????????????????\n");
            return false;
        }
        
        uint32_t victim_page = memory_manager.frames[victim_frame].virtual_page_num;
        printf("?????? %u ????? %u (??? %u) ???????\n", 
               victim_process->pid, victim_page, victim_frame);
        
        // ?????R?????????д??????
        if (memory_manager.frames[victim_frame].is_dirty) {
            vm_manager.stats.disk_writes++;
            if (!swap_out_page(victim_frame)) {
                printf("??????I?????\n");
                return false;
            }
            vm_manager.stats.pages_swapped_out++;
            victim_process->stats.pages_swapped_out++;
        }
        
        // ???±?????????????
        PageTableEntry* victim_pte = &victim_process->page_table[victim_page];
        victim_pte->flags.present = false;
        victim_pte->flags.swapped = true;
        victim_pte->frame_number = (uint32_t)-1;
        
        // ?????????????????
        frame = victim_frame;
        memory_manager.frames[frame].is_allocated = true;
        memory_manager.frames[frame].process_id = process->pid;
        memory_manager.frames[frame].virtual_page_num = virtual_page;
        memory_manager.frames[frame].last_access_time = get_current_time();
        memory_manager.frames[frame].is_dirty = false;
    }
    
    // ??????????????????????
    if (pte->flags.swapped) {
        vm_manager.stats.disk_reads++;
        process->stats.pages_swapped_in++;
        if (!swap_in_page(process->pid, virtual_page, frame)) {
            printf("?????????????\n");
            return false;
        }
    }
    
    // ?????????
    pte->frame_number = frame;
    pte->flags.present = true;
    pte->flags.swapped = false;
    pte->last_access_time = get_current_time();
    
    printf("??? %u ????????? %u\n", virtual_page, frame);
    
    return true;
}

/**
 * @brief ?????????????????
 * 
 * @param process ??????????PCB
 */
void dump_page_table(PCB* process) {
    printf("\n=== ????? (PID=%u) ===\n", process->pid);
    int present_count = 0, swapped_count = 0;
    
    // ???????????????
    for (uint32_t i = 0; i < process->page_table_size; i++) {
        PageTableEntry* pte = &process->page_table[i];
        if (pte->flags.present || pte->flags.swapped) { // ??????????л???????????
            printf("???: %u, ??: %s%s, ???: %u\n",
                   i,
                   pte->flags.present ? "?????" : "δ????",
                   pte->flags.swapped ? ", ?????" : "",
                   pte->flags.present ? pte->frame_number : pte->flags.swap_index);
            
            // ?????????????
            if (pte->flags.present) present_count++;
            if (pte->flags.swapped) swapped_count++;
        }
    }
    
    // ?????????
    printf("\n???????: %d, ??????????: %d\n",
           present_count, swapped_count);
}

/**
 * @brief ???????????????????????з???????
 */
void vm_shutdown(void) {
    free(vm_manager.swap_blocks); // ???????????????
    free(vm_manager.swap_area);   // ???????????????
}

/**
 * @brief ????????????????????
 * 
 * @param process_id ????ID
 * @param virtual_page ???????
 * @return uint32_t ?????????????????????? -1
 */
uint32_t allocate_swap_block(uint32_t process_id, uint32_t virtual_page) {
    if (vm_manager.swap_free_blocks == 0) { // ???????п??н?????
        return (uint32_t)-1;
    }

    // ?????????????????δ?????????
    for (uint32_t i = 0; i < SWAP_SIZE; i++) {
        if (!vm_manager.swap_blocks[i].is_used) {
            vm_manager.swap_blocks[i].is_used = true; // ?????????
            vm_manager.swap_blocks[i].process_id = process_id; // ???????ID
            vm_manager.swap_blocks[i].virtual_page = virtual_page; // ??????????
            vm_manager.swap_free_blocks--; // ??????н????????
            return i; // ?????????????
        }
    }
    return (uint32_t)-1; // δ??????н?????
}

/**
 * @brief ????????????
 * 
 * @param swap_index ??????????????
 */
void free_swap_block(uint32_t swap_index) {
    // ????????????Ч????????
    if (swap_index < SWAP_SIZE && vm_manager.swap_blocks[swap_index].is_used) {
        vm_manager.swap_blocks[swap_index].is_used = false; // ????δ???
        vm_manager.swap_blocks[swap_index].process_id = 0; // ???????ID
        vm_manager.swap_blocks[swap_index].virtual_page = 0; // ??????????
        vm_manager.swap_free_blocks++; // ??????н????????
    }
}

/**
 * @brief ????????????????
 * 
 * @param process ??????????PCB
 * @param page_num ?????????????
 * @return true ???????
 * @return false ???????
 */
bool page_out(PCB* process, uint32_t page_num) {
    // ??????????????????
    if (!process || page_num >= process->page_table_size ||
        !process->page_table[page_num].flags.present) {
        printf("??????? %u ?????????\n", page_num);
        return false;
    }

    PageTableEntry* pte = &process->page_table[page_num];
    // ????????????????
    if (!pte->flags.present) {
        printf("??????? %u ?????????\n", page_num);
        return false;
    }

    // ???佻????
    uint32_t swap_index = allocate_swap_block(process->pid, page_num);
    if (swap_index == (uint32_t)-1) { // ???????????
        printf("??????????佻???飨??????%u??\n", 
               vm_manager.swap_free_blocks);
        return false;
    }

    // ????????????????????
    uint8_t page_data[PAGE_SIZE];
    if (!read_physical_memory(pte->frame_number, 0, page_data, PAGE_SIZE)) {
        printf("???????????????????????????????%u??\n", 
               pte->frame_number);
        free_swap_block(swap_index); // ???????????????
        return false;
    }
    
    // ?????????д??????
    if (!write_to_swap(swap_index, page_data)) {
        printf("???????д????????????????%u??\n", swap_index);
        free_swap_block(swap_index); // д??????????????
        return false;
    }

    // ???????????????????
    free_frame(pte->frame_number); // ????????
    pte->frame_number = (uint32_t)-1; // ???????
    pte->flags.present = false; // ?????治???????
    pte->flags.swapped = true; // ???????????
    pte->flags.swap_index = swap_index; // ?????????????
    
    // ?????????????
    vm_manager.stats.page_replacements++;
    printf("??? %u ????????????? %u\n", page_num, swap_index);
    return true;
}

/**
 * @brief ???????????
 * 
 * @param process ??????????PCB
 * @param virtual_page ?????????????
 * @return true ??????
 * @return false ???????
 */
bool page_in(PCB* process, uint32_t virtual_page) {
    // ?????????????Ч??
    if (!process || virtual_page >= process->page_table_size) {
        return false;
    }

    PageTableEntry* pte = &process->page_table[virtual_page];
    // ??????????????
    if (!pte->flags.swapped) {
        return false; // ???δ???????????????
    }

    // ????????????
    uint32_t frame = allocate_frame(process->pid, virtual_page);
    if (frame == (uint32_t)-1) { // ??治??
        uint32_t victim_page = select_victim_page(process); // ?????????
        if (victim_page != (uint32_t)-1) {
            printf("?????? %u ???н???\n", victim_page);
            if (page_out(process, victim_page)) { // ???????????
                frame = allocate_frame(process->pid, virtual_page); // ??γ???????
            }
        }
    }

    if (frame == (uint32_t)-1) { // ??????????????
        return false;
    }

    // ????????????????
    uint8_t page_data[PAGE_SIZE];
    uint32_t swap_index = pte->flags.swap_index;
    if (!read_from_swap(swap_index, page_data)) {
        free_frame(frame); // ???????????
        return false;
    }

    // ?????????д?????????
    if (!write_physical_memory(frame, 0, page_data, PAGE_SIZE)) {
        free_frame(frame); // д??????????
        return false;
    }

    // ??????????????????????
    pte->frame_number = frame;
    pte->flags.present = true; // ?????????????
    pte->flags.swapped = false; // ???????λ
    
    printf("??? %u ????????????? %u\n", 
           virtual_page, swap_index);
    return true;
}

/**
 * @brief ?????????е??????????
 * 
 * @return uint32_t ???н?????????
 */
uint32_t get_free_swap_blocks(void) {
    return vm_manager.swap_free_blocks;
}

/**
 * @brief ?????????????????
 */
void print_vm_stats(void) {
    float page_fault_rate = vm_manager.stats.total_accesses > 0 ? 
        (float)vm_manager.stats.page_faults * 100 / vm_manager.stats.total_accesses : 0;
    
    printf("=== ????????? ===\n");
    printf("????????: %u\n", vm_manager.stats.total_accesses);
    printf("??????: %u (%.1f%%)\n", vm_manager.stats.page_faults, page_fault_rate);
    printf("????I????: %u\n", vm_manager.stats.page_replacements);
    printf("д????????: %u\n", vm_manager.stats.disk_writes);
    printf("??I??????: %u\n", vm_manager.stats.pages_swapped_out);
    printf("??I?????: %u\n", vm_manager.stats.pages_swapped_in);
    
    printf("\n=== ???????? ===\n");
    printf("?????????: %u\n", SWAP_SIZE);
    printf("?????????: %u\n", SWAP_SIZE - vm_manager.swap_free_blocks);
    printf("???н?????: %u\n", vm_manager.swap_free_blocks);
    
    float fragmentation = 0;
    if (memory_manager.free_frames_count > 0) {
        uint32_t fragments = count_memory_fragments();
        fragmentation = (float)fragments * 100 / memory_manager.free_frames_count;
    }
    
    printf("\n=== ????????? ===\n");
    printf("?????????: %u\n", memory_manager.free_frames_count);
    printf("?????: %u\n", count_memory_fragments());
    printf("?????: %.1f%%\n", fragmentation);
}

/**
 * @brief ??????????????????
 * 
 * @param process ??????????PCB
 * @return uint32_t ???????????δ?????? -1
 */
uint32_t select_victim_page(PCB* process) {
    uint32_t victim_page = (uint32_t)-1;
    uint64_t oldest_access = UINT64_MAX;
    
    for (uint32_t i = 0; i < process->page_table_size; i++) {
        if (process->page_table[i].flags.present) {
            if (process->page_table[i].last_access_time < oldest_access) {
                oldest_access = process->page_table[i].last_access_time;
                victim_page = i;
            }
        }
    }
    return victim_page;
}

/**
 * @brief ?????????д???????????
 * 
 * @param process ??????????PCB
 * @param virtual_address ?д?????????
 * @param data ?д??????????
 * @param size ?д????????С
 * @return true д????
 * @return false д?????
 */
bool write_page_data(PCB* process, uint32_t virtual_address, const void* data, size_t size) {
    uint32_t page_num = virtual_address / PAGE_SIZE;
    if (!process || page_num >= process->page_table_size) {
        return false;
    }

    // ?????????????
    if (!process->page_table[page_num].flags.present) {
        if (!handle_page_fault(process, virtual_address)) {
            return false;
        }
    }

    // ????????????д??????
    uint32_t frame = process->page_table[page_num].frame_number;
    if (!write_physical_memory(frame, 0, data, size)) {
        return false;
    }

    // ?????????
    process->page_table[page_num].last_access_time = get_current_time();
    return true;
}

/**
 * @brief ?????????????????????
 * 
 * @param process ??????????PCB
 * @param virtual_address ????????????
 * @param buffer ??????????????
 * @param size ???????????С
 * @return true ??????
 * @return false ??????
 */
bool read_page_data(PCB* process, uint32_t virtual_address, void* buffer, size_t size) {
    uint32_t page_num = virtual_address / PAGE_SIZE;
    if (!process || page_num >= process->page_table_size) {
        return false;
    }

    // ?????????????
    if (!process->page_table[page_num].flags.present) {
        if (!handle_page_fault(process, virtual_address)) {
            return false;
        }
    }

    // ???????????????????
    uint32_t frame = process->page_table[page_num].frame_number;
    if (!read_physical_memory(frame, 0, buffer, size)) {
        return false;
    }

    // ?????????
    process->page_table[page_num].last_access_time = get_current_time();
    return true;
}

/**
 * @brief ??????д?????????????????
 * 
 * @param swap_index ??????????
 * @param data ?д??????????
 * @return true д????
 * @return false д?????
 */
bool write_to_swap(uint32_t swap_index, const void* data) {
    if (swap_index >= SWAP_SIZE || !data) { // ??????????????????Ч??
        return false;
    }

    // ???????????????
    if (!vm_manager.swap_blocks[swap_index].is_used) {
        return false;
    }

    // ?????????н????????????
    uint8_t* dest = (uint8_t*)vm_manager.swap_area + (swap_index * SWAP_BLOCK_SIZE);
    memcpy(dest, data, SWAP_BLOCK_SIZE); // ????????????????
    vm_manager.stats.writes_to_disk++; // ????д????????

    return true; // д????
}

/**
 * @brief ?????????????????????
 * 
 * @param swap_index ??????????
 * @param buffer ??????????????
 * @return true ??????
 * @return false ??????
 */
bool read_from_swap(uint32_t swap_index, void* buffer) {
    if (swap_index >= SWAP_SIZE || !buffer) { // ???????????????????Ч??
        return false;
    }

    // ???????????????
    if (!vm_manager.swap_blocks[swap_index].is_used) {
        return false;
    }

    // ?????????н????????????
    uint8_t* src = (uint8_t*)vm_manager.swap_area + (swap_index * SWAP_BLOCK_SIZE);
    memcpy(buffer, src, SWAP_BLOCK_SIZE); // ????????????????

    return true; // ??????
}

/**
 * @brief ????????????????
 * 
 * @return SwapBlockInfo* ?????????????????
 */
SwapBlockInfo* get_swap_blocks(void) {
    return vm_manager.swap_blocks;
}

/**
 * @brief ?????????????????????
 * 
 * @return void* ?????????????????
 */
void* get_swap_area(void) {
    return vm_manager.swap_area;
}

/**
 * @brief ?????????????????
 * 
 * @return MemoryStats ?????????????
 */
MemoryStats get_memory_stats(void) {
    return vm_manager.stats;
}

/**
 * @brief ???????????????????????е??????
 */
void clean_swap_area(void) {
    for (uint32_t i = 0; i < SWAP_BLOCKS; i++) {
        if (vm_manager.swap_blocks[i].is_used) { // ????????????
            vm_manager.swap_blocks[i].is_used = false; // ????δ???
            vm_manager.swap_blocks[i].process_id = 0; // ???????ID
            vm_manager.swap_blocks[i].virtual_page = 0; // ??????????
            vm_manager.swap_free_blocks++; // ??????н????????
        }
    }
}

/**
 * @brief ????????????????????????????????????к???????????
 */
void print_swap_status(void) {
    uint32_t used_blocks = 0;
    // ??????????????????
    for (uint32_t i = 0; i < SWAP_BLOCKS; i++) {
        if (vm_manager.swap_blocks[i].is_used) {
            used_blocks++;
        }
    }
    printf("???????: %u\n", SWAP_BLOCKS);
    printf("???н?????: %u\n", SWAP_BLOCKS - used_blocks);
    printf("??????????: %u\n", used_blocks);
    
    printf("\n????????\n");
    // ?????????????????????
    for (uint32_t i = 0; i < SWAP_BLOCKS; i++) {
        if (vm_manager.swap_blocks[i].is_used) {
            printf(" %u: PID=%u, ???=%u\n",
                   i,
                   vm_manager.swap_blocks[i].process_id,
                   vm_manager.swap_blocks[i].virtual_page);
        }
    }
}

/**
 * @brief ???????I??????
 * 
 * @return uint32_t ????I??????
 */
uint32_t get_last_replaced_page(void) {
    return vm_manager.stats.last_replaced_page;
}

/**
 * @brief ????????I????????
 * 
 * @param page_num ???I??????
 */
void update_replacement_stats(uint32_t page_num) {
    vm_manager.stats.page_replacements++; // ????????I????
    vm_manager.stats.last_replaced_page = page_num; // ???????I??????
    printf("????I????? %u ???I???I???? %u\n", 
           page_num, vm_manager.stats.page_replacements);
}

/**
 * @brief ?????д??????
 * 
 * @param frame ?д???????
 * @return true д????
 * @return false д?????
 */
bool swap_out_page(uint32_t frame) {
    if (frame >= PHYSICAL_PAGES || !memory_manager.frames[frame].is_allocated) {
        printf("??????Ч?????? %u\n", frame);
        return false;
    }

    FrameInfo* frame_info = &memory_manager.frames[frame];
    PCB* process = get_process_by_pid(frame_info->process_id);
    if (!process) {
        printf("????????????? %u\n", frame_info->process_id);
        return false;
    }

    uint32_t virtual_page = frame_info->virtual_page_num;
    if (virtual_page >= process->page_table_size) {
        printf("??????????? %u ??????Χ\n", virtual_page);
        return false;
    }

    // ???佻????
    uint32_t swap_index = allocate_swap_block(process->pid, virtual_page);
    if (swap_index == (uint32_t)-1) {
        printf("??????????佻????\n");
        return false;
    }

    // ?????????д??????
    void* page_data = get_physical_memory() + (frame * PAGE_SIZE);
    if (!write_to_swap(swap_index, page_data)) {
        printf("????д?????????\n");
        free_swap_block(swap_index);
        return false;
    }

    // ?????????
    PageTableEntry* pte = &process->page_table[virtual_page];
    pte->flags.present = false;
    pte->flags.swapped = true;
    pte->flags.swap_index = swap_index;

    // ??????????
    if (frame_info->is_dirty) {
        vm_manager.stats.disk_writes++;
    }
    vm_manager.stats.pages_swapped_out++;

    // ?????????
    frame_info->is_allocated = false;
    frame_info->process_id = 0;
    frame_info->virtual_page_num = 0;
    frame_info->is_dirty = false;
    memory_manager.free_frames_count++;

    printf("?????д????????????=%u, ???????=%u, ??????=%u\n", 
           process->pid, virtual_page, swap_index);

    return true;
}

/**
 * @brief ?????????
 * 
 * @return uint64_t ??????
 */
uint64_t get_current_time(void) {
#ifdef _WIN32
    // Windows?????GetSystemTimeAsFileTime
    FILETIME ft;
    GetSystemTimeAsFileTime(&ft);
    ULARGE_INTEGER uli;
    uli.LowPart = ft.dwLowDateTime;
    uli.HighPart = ft.dwHighDateTime;
    // ??????? (Windows?????????1601?????100??????)
    return (uli.QuadPart - 116444736000000000ULL) / 10;
#else
    // ??Windows?????clock_gettime
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (ts.tv_sec * 1000000) + (ts.tv_nsec / 1000);
#endif
}

/**
 * @brief ???????????????
 */
void print_page_replacement_stats(void) {
    printf("\n=== ???????????? ===\n");
    printf("????????: %u\n", page_stats.total_page_faults);
    printf("??????????: %u\n", page_stats.page_replacements);
    printf("??????????: %u\n", page_stats.disk_reads);
    printf("????д?????: %u\n", page_stats.disk_writes);
    printf("LRU??????: %.2f%%\n", 
           page_stats.lru_hits + page_stats.lru_misses > 0 ?
           (float)page_stats.lru_hits / (page_stats.lru_hits + page_stats.lru_misses) * 100 : 0);
}

/**
 * @brief 从交换区将页面加载到内存
 * 
 * @param pid 进程ID
 * @param virtual_page 虚拟页号
 * @param frame 目标页框号
 * @return true 加载成功
 * @return false 加载失败
 */
bool swap_in_page(uint32_t pid, uint32_t virtual_page, uint32_t frame) {
    // 检查参数有效性
    if (frame >= PHYSICAL_PAGES) {
        printf("错误：无效的页框号 %u\n", frame);
        return false;
    }

    // 查找对应的交换区块
    uint32_t swap_index = (uint32_t)-1;
    for (uint32_t i = 0; i < SWAP_SIZE; i++) {
        if (vm_manager.swap_blocks[i].is_used &&
            vm_manager.swap_blocks[i].process_id == pid &&
            vm_manager.swap_blocks[i].virtual_page == virtual_page) {
            swap_index = i;
            break;
        }
    }

    if (swap_index == (uint32_t)-1) {
        printf("错误：在交换区中找不到进程 %u 的页面 %u\n", pid, virtual_page);
        return false;
    }

    // 读取交换区数据
    uint8_t page_data[PAGE_SIZE];
    if (!read_from_swap(swap_index, page_data)) {
        printf("错误：从交换区读取数据失败\n");
        return false;
    }

    // 将数据写入物理内存
    if (!write_physical_memory(frame, 0, page_data, PAGE_SIZE)) {
        printf("错误：写入物理内存失败\n");
        return false;
    }

    // 释放交换区块
    free_swap_block(swap_index);

    // 更新统计信息
    vm_manager.stats.disk_reads++;
    vm_manager.stats.pages_swapped_in++;

    printf("页面成功从交换区加载到内存：PID=%u, 虚拟页号=%u, 页框=%u\n", 
           pid, virtual_page, frame);
    return true;
}
